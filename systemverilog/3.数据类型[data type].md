# 数据类型

## 简介

  为了提供与C之间更简洁地互译，SV支持C的内置类型，其语义由C编译器实现。然而，为了避免**int**和**long**的重复导致的冲突，在SV中，**int**是32bit，**longint**是64bit。C语言中的**float**对应与SV中的**shortreal**，这样就不会与Verilog-2001中的**real**类型冲突。
  
  Verilog-2001拥有线网(net)、reg 数据类型，它们都是四值逻辑即0，1，X，Z但用途不同。SV在此基础上添加了另一种4值逻辑数据类型 -> logic。
  
  SV添加了string、chandle、class数据类型，加强了verilog的event类型。
  
  verilog-2001使用reg数据类型提供任意固定长度的四则运算，reg类型的位可以是X或Z，然而，这比bit类型的数组低效的多，这是因为每一次运算都要检查X和Z，必须存储两次数据，SV添加了bit2值逻辑的数据类型。
  
  如果无符号或者符号拓展(有符号), 从较小bit位的数到较大bit位的数的自动类型转换涉及0的拓展，并不会导致警告信息的出现。反之，从较大数到较小数的自动截断会导致警告信息，
  从logic到bit的转换不会有警告信息出现，1转换为1，其余转换为0。
  ```
  当用更多的内存存储某一个有符号数时，由于符号位位于该数的第一位，扩展之后，符号位仍然需要位于第一位，
  
  所以，当扩展一个负数的时候需要将扩展的高位全赋为1.
  
  对于正数而言，符号扩展和零扩展是一样的，因为符号位就是0. 
  
  比如一个用一个8位 二进制表示-1，则是10000001 如果把这个书用16位二进制表示时， 则为11111111 10000001 高位全都是1，
  
  这个叫做符号扩展，主要用于对其操作数。
  ```
  
  用户自定义的数据类型由**typedef**引入，且必须在使用前定义。数据类型也可以是模块或接口的参数，这使它们类似于面向对象编程中的类模板。一个例程可以被写为翻转数组中的元素顺序，这在c和verilog中是不可能的。
  
  结构体(struct)和联合体(union)由于tags有不同的命名空间，因此在c语言中是十分复杂的，sv学了了c的语法特点，但是没有可选择的结构tags。
  
## 数据类型语法

data_type ::= 

            integer_vector_type [ signing ] { packed_dimension } 
            | integer_atom_type [ signing ] 
            | non_integer_type 
            | struct_union [ packed [ signing ] ] { struct_union_member { struct_union_member } { packed_dimension }
            | enum [ enum_base_type ] { enum_name_declaration { , enum_name_declaration } }
            | string
            | chandle
            | virtual [ interface ] interface_identifier 
            | [ class_scope | package_scope ] type_identifier { packed_dimension } 
            | class_type 
            | event
            | ps_covergroup_identifier
            
enum_base_type ::= 

            integer_atom_type [ signing ] 
            | integer_vector_type [ signing ] [ packed_dimension ] 
            | type_identifier [ packed_dimension ]
            
enum_name_declaration ::= 

            enum_identifier [ [ integral_number [ : integral_number ] ] ] [ = constant_expression ] 
            
class_scope ::= class_type ::

class_type ::= 

            ps_class_identifier [ parameter_value_assignment ] 
            { :: class_identifier [ parameter_value_assignment ] } 
            
integer_type ::= integer_vector_type | integer_atom_type 

integer_atom_type ::= byte | shortint | int | longint | integer | time

integer_vector_type ::= bit | logic | reg

non_integer_type ::= shortreal | real | realtime

net_type ::= supply0 | supply1 | tri | triand | trior | tri0 | tri1 | wire | wand | wor

signing ::= signed | unsigned

simple_type ::= integer_type | non_integer_type | ps_type_identifier 

struct_union_member27 ::= 
            { attribute_instance } data_type_or_void list_of_variable_identifiers ;
            
data_type_or_void ::= data_type | void

struct_union ::= struct | union [ tagged ] 

variable_decl_assignment ::= 

            variable_identifier variable_dimension [ = expression ] 
            | dynamic_array_variable_identifier [ ] [ = dynamic_array_new ] 
            | class_variable_identifier [ = class_new ] 
            | [ covergroup_variable_identifier ] = new [ ( list_of_arguments ) ]            

## 整数数据类型
